// ******************************************************************
// This file is part of the Silent Engine.
// Copyright Aleksandr "Flone" Tretyakov (github.com/Flone-dnb).
// Licensed under the ZLib license.
// Refer to the LICENSE file included.
// ******************************************************************

#pragma once

#include <mutex>

class SApplication;
class SGUILayout;
class SGUISimpleText;

#if defined(DEBUG) || defined(_DEBUG)
// note that these values may be a little incorrect
struct SFrameStats
{
	// we handle all messages before drawing a frame
	// this includes user input handling, like onMouseMove() or onKeyboardButtonDown()
	// this is the first thing that we will do before drawing a frame
	float fTimeSpentOnWindowsMessagesInMS = 0.0f;
	// on tick is called before drawing a frame
	// this is the second thing that we will do before drawing a frame
	float fTimeSpentOnUserOnTickFunctionInMS = 0.0f;
	// time spent updating position of the sounds in all 3D audio components
	// this is the third thing that we will do before drawing a frame
	float fTimeSpentOn3DAudioUpdateInMS = 0.0f;
	// if this value is not 0, then this means that the CPU submitted SFRAME_RES_COUNT frames to the GPU but the GPU
	// is still drawing the first frame (out of SFRAME_RES_COUNT frames) and because of this the CPU will wait (so CPU will be idle)
	// until the GPU finishes drawing this frame to submit another frame
	// if the CPU is too fast (or GPU has too much work) the CPU will need to wait for the GPU to catch up
	// the more this value is the more likely that you have a GPU bottleneck
	// if this value is always 0 then you may have a CPU bottleneck
	// NOTICE: if this value is 0 but you have an FPS limit set then this value should not be considered,
	// because if the FPS limit is set the CPU will sleep to maintain the FPS limit,
	// YOU SHOULD ONLY CONSIDER THIS VALUE IF THE FPS LIMIT IS DISABLED
	// this is the fourth thing that we will do before drawing a frame
	// you can also get this value in release builds using SProfiler::getTimeSpentWaitingForGPUBetweenFramesInMS().
	float fTimeSpentWaitingForGPUInUpdateInMS = 0.0f;
	// update() will update all constant buffers (if they were changed)
	// this value does not include fTimeSpentOnCPUSleepInUpdate they are separate values
	// this is the fourth thing that we will do before drawing a frame
	float fTimeSpentOnUpdateInMS = 0.0f;
	// time spent on the CPU in the draw() function
	// that submits a new frame to the GPU
	float fTimeSpentOnCPUDrawInMS = 0.0f;
	// time spent in calculateFrameStats() func that updates the FPS counter and
	// optionally (if enabled) shows avr. time to render a frame in the window title.
	// after the frame is drawn
	float fTimeSpentOnFPSCalcInMS = 0.0f;
	// when fps limit is set
	// after the frame is drawn
	float fTimeSpentInFPSLimitSleepInMS = 0.0f;
	// this value is independent and does not relate to the main rendering thread
	float fTimeSpentOnUserPhysicsTickFunctionInMS = 0.0f;
};
#endif

//@@Class
/*
The class is used for dynamic analysis, for example, for measuring draw call amount, FPS, or video memory used by the app.
*/
class SProfiler
{
public:
	//@@Function
	SProfiler(SApplication* pApp);
	SProfiler() = delete;
	SProfiler(const SProfiler&) = delete;
	SProfiler& operator= (const SProfiler&) = delete;


	//@@Function
	/*
	* desc: returns the time in seconds elapsed since the SApplication::run() was called.
	* param "fTimeInSec": pointer to your float value which will be used to set the time value.
	* return: false if successful, true otherwise.
	* remarks: should be called after calling the SApplication::run().
	*/
	bool   getTimeElapsedFromStart      (float* fTimeInSec) const;
	//@@Function
	/*
	* desc: returns the current number of frames per second generated by the application.
	* param "iFPS": pointer to your int value which will be used to set the FPS value.
	* return: false if successful, true otherwise.
	* remarks: should be called after calling the SApplication::run().
	*/
	bool   getFPS                       (int* iFPS) const;
	//@@Function
	/*
	* desc: returns the time it was taken to render the last frame.
	* param "fTimeInMS": pointer to your float value which will be used to set the time value.
	* return: false if successful, true otherwise.
	* remarks: should be called after calling the SApplication::run().
	*/
	bool   getTimeToRenderFrame        (float* fTimeInMS) const;
#if defined(DEBUG) || defined(_DEBUG)
	//@@Function
	/*
	* desc: returns the frame stats of the last drawn frame.
	* remarks: this function is only available in the debug builds.
	*/
	SFrameStats getFrameStats          ();
	//@@Function
	/*
	* desc: used to show SFrameStats on the screen.
	*/
	void     showOnScreen              (bool bShow, float fDataUpdateIntervalInMS = 100.0f);
	//@@Function
	/*
	* desc: returns 'true' if the last call to the showOnScreen() was with 'true' value.
	*/
	bool     isShownOnScreen           () const;
#endif
	//@@Function
	/*
	* desc: used to retrieve the member fTimeSpentWaitingForGPUInUpdateInMS of the SFrameStats struct (getFrameStats() in debug) in release builds.
	* remarks: see comments of the member fTimeSpentWaitingForGPUInUpdateInMS for description.
	*/
	float    getTimeSpentWaitingForGPUBetweenFramesInMS        ();
	//@@Function
	/*
	* desc: returns the number of the draw calls it was made to render the last frame.
	* param "iDrawCallCount": pointer to your unsigned long long value which will be used to set the draw call count value.
	* return: false if successful, true otherwise.
	* remarks: should be called on tick(), otherwise it will have an incorrect number. The function is also should be
	called only after calling the SApplication::run().
	*/
	bool   getLastFrameDrawCallCount                         (unsigned long long* iDrawCallCount) const;
	//@@Function
	/*
	* desc: returns currently used memory space (i.e. how much of the VRAM is used) of the display adapter (i.e. "video card").
	* param "pSizeInBytes": pointer to your unsigned long long value which will be used to set the memory value.
	* return: false if successful, true otherwise.
	* remarks: should be called after calling the SApplication::init().
	*/
	bool   getVideoMemoryUsageInBytesOfCurrentDisplayAdapter (unsigned long long* pSizeInBytes);


private:

	friend class SApplication;

#if defined(DEBUG) || defined(_DEBUG)

	bool initNeededGUIObjects();

	void setFrameStats(const SFrameStats& frameStats);

	void updateFrameStatsOnScreen();

	std::wstring floatToWstring(float fValue, size_t iPrecision);

	SFrameStats lastFrameStats;
	std::mutex mtxFrameStats;
	SGUILayout* pNameLayout = nullptr; // for showOnScreen()
	SGUILayout* pValueLayout = nullptr; // for showOnScreen()
	SGUISimpleText* pFPSText = nullptr;
	float fUpdateGUIIntervalInMS = 100.0f;
	float fLastCheckTime = 0.0f;
	bool bFrameStatsShownOnScreen = false;
#endif

	float fTimeSpentWaitingForGPUBetweenFramesInMS = 0.0f;

	//@@Variable
	/* pointer to the SApplication which will be profiled. */
	SApplication* pApp;
};

